<?xml version="1.0" encoding="UTF-8"?>

<!-- ===== #28. mapper 기본 설정 ===== -->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- ===== #29. 루트 엘리먼트 및 네임스페이스 설정하기(이 네임스페이스의 이름은 프로젝트 전체 내에서 반드시 고유해야만 한다.) ===== -->
<mapper namespace="jghBook">

	<!-- 검색조건에 따른 삭제도서 목록 조회 -->
	<select id="findAllDeleteBookBySearchOption" parameterType="HashMap" resultType="com.spring.bookmanage.book.JGHmodel.DeleteBookVO">
		select rownum as rno, bookid, title, author, pubname, agecode, count, delid, deldate, cleanerid
		from
			(
			select distinct substr(D.bookid,1, instr(D.bookid,'-',1,2)-1 ) as bookid
				, title, author, pubname, agecode, count, delid
				, to_char(deldate, 'yyyy-mm-dd') as deldate, cleanerid
			from delete_book D join publisher P
			on D.pubcode = P.pubcode
			join ( select substr(bookid,1, instr(bookid,'-',1,2)-1 ) as bookid,  count(*) as count
			        from delete_book group by substr(bookid,1, instr(bookid,'-',1,2)-1 )
			      ) V
			on substr(D.bookid, 1, instr(D.bookid,'-',1,2)-1 ) = V.bookid
			where ${colname} like '%'||#{searchWord}||'%'
			) T
		order by deldate desc, rno asc
	</select>
	
	<!-- 검색조건없는 삭제도서 목록 조회(도서삭제 목록 전체조회) -->
	<select id="findAllDeleteBook" resultType="com.spring.bookmanage.book.JGHmodel.DeleteBookVO">
		select rownum as rno, bookid, title, author, pubname, agecode, count, delid, deldate, cleanerid
		from
			(
			select distinct substr(D.bookid,1, instr(D.bookid,'-',1,2)-1 ) as bookid
				, title, author, pubname, agecode, count, delid
				, to_char(deldate, 'yyyy-mm-dd') as deldate, cleanerid
			from delete_book D join publisher P
			on D.pubcode = P.pubcode
			join ( select substr(bookid,1, instr(bookid,'-',1,2)-1 ) as bookid,  count(*) as count
			        from delete_book group by substr(bookid,1, instr(bookid,'-',1,2)-1 )
			     ) V
			on substr(D.bookid, 1, instr(D.bookid,'-',1,2)-1 ) = V.bookid
			) T
		order by deldate desc, rno asc
	</select>
	
	<select id="findAllDeleteBookByDelid" parameterType="HashMap">
		select rownum as rno, bookid, title, author, pubname, agecode, count, delid, deldate, cleanerid
		from
			(
			select distinct substr(D.bookid,1, instr(D.bookid,'-',1,2)-1 ) as bookid
				, title, author, pubname, agecode, count, delid
				, to_char(deldate, 'yyyy-mm-dd') as deldate, cleanerid
			from delete_book D join publisher P
			on D.pubcode = P.pubcode
			join ( select substr(bookid,1, instr(bookid,'-',1,2)-1 ) as bookid,  count(*) as count
			        from delete_book group by substr(bookid,1, instr(bookid,'-',1,2)-1 )
			     ) V
			on substr(D.bookid, 1, instr(D.bookid,'-',1,2)-1 ) = V.bookid
			) T
		where delid in
		<foreach collection="delidArray" index="i" open="(" separator="," close=")"> <!-- 반복횟수 : index  시작 열기 : open  구분자 : separator 끝 닫기 : close -->
	         ${delidArray[i]}
	    </foreach>
		order by deldate desc, rno asc
	</select>
	
	<!-- Transaction, 도서삭제 이전에 도서테이블에 값을 삽입 -->
	<!-- <insert id="insertBook" parameterType="com.spring.bookmanage.book.DeleteBookVO">
		insert into book(idx, bookid, title, author, pubcode_fk, status, agecode, isbn, ncode_fk, lcode_fk, fcode_fk, ccode_fk, gcode_fk, libcode_fk)
		value(book_seq.nextval,${bookid}, ${title}, ${author}, ${pubcode_fk}, ${status}, ${agecode}, ${ISBN}, ${ncode_fk}, ${lcode_fk}, ${fcode_fk}, ${ccode_fk}, ${gcode_fk}, ${libcode_fk} )
	</insert> -->

</mapper>